<!DOCTYPE html>
<html>
<head>
    <title>WASM & Audio Library Test</title>
    <style>
        body {
            font-family: monospace;
            background: #000;
            color: #00ff00;
            padding: 20px;
        }
        .test {
            margin: 10px 0;
            padding: 10px;
            border: 1px solid #004400;
        }
        .pass { border-color: #00ff00; background: rgba(0,255,0,0.1); }
        .fail { border-color: #ff0000; background: rgba(255,0,0,0.1); color: #ff4444; }
        .warn { border-color: #ffaa00; background: rgba(255,170,0,0.1); color: #ffaa00; }
        button {
            background: #000;
            border: 2px solid #00ff00;
            color: #00ff00;
            padding: 8px 16px;
            margin: 5px;
            cursor: pointer;
            font-family: monospace;
        }
        button:hover { background: rgba(0,255,0,0.1); }
        #log {
            background: rgba(0,34,0,0.3);
            border: 1px solid #004400;
            padding: 10px;
            margin-top: 20px;
            max-height: 400px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <h1>ðŸ”§ WASM & Audio Library Comprehensive Test</h1>
    
    <div id="results"></div>
    
    <h2>Manual Tests</h2>
    <button onclick="checkOpenMPT()">Check OpenMPT Status</button>
    <button onclick="testChiptunePlayback()">Test Chiptune Playback</button>
    <button onclick="testMidiPlayback()">Test MIDI Playback</button>
    <button onclick="downloadTestFile()">Download Test File</button>
    
    <h2>Console Log</h2>
    <div id="log"></div>

    <!-- Load libraries in correct order -->
    <script src="/js/libopenmpt.js"></script>
    <script src="/js/openmpt-loader.js"></script>
    <script src="/js/chiptune2.js"></script>
    <script src="/js/webaudio-tinysynth.js"></script>
    <script src="/js/midi-parser.js"></script>
    
    <script>
        let logBuffer = [];
        
        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const entry = `[${timestamp}] ${type.toUpperCase()}: ${message}`;
            console.log(entry);
            logBuffer.push(entry);
            
            const logEl = document.getElementById('log');
            if (logEl) {
                logEl.innerHTML = logBuffer.slice(-50).join('<br>');
                logEl.scrollTop = logEl.scrollHeight;
            }
        }
        
        function addResult(test, status, message) {
            const div = document.createElement('div');
            div.className = `test ${status}`;
            div.innerHTML = `<strong>${test}:</strong> ${status.toUpperCase()} - ${message}`;
            document.getElementById('results').appendChild(div);
            log(`${test}: ${status} - ${message}`, status);
        }
        
        async function runTests() {
            document.getElementById('results').innerHTML = '';
            log('Starting comprehensive tests...');
            
            // Test 1: Check if Module exists
            if (typeof Module !== 'undefined') {
                addResult('Module Object', 'pass', 'Emscripten Module exists');
                
                // Check critical functions
                const functions = [
                    '_openmpt_module_create_from_memory',
                    '_openmpt_module_read_float_stereo',
                    '_openmpt_module_destroy',
                    '_malloc',
                    '_free'
                ];
                
                for (const func of functions) {
                    if (typeof Module[func] === 'function') {
                        addResult(`Module.${func}`, 'pass', 'Function available');
                    } else {
                        addResult(`Module.${func}`, 'fail', 'Function not found');
                    }
                }
            } else {
                addResult('Module Object', 'fail', 'Emscripten Module not found');
            }
            
            // Test 2: Check if libopenmpt exists
            if (typeof libopenmpt !== 'undefined') {
                addResult('libopenmpt Global', 'pass', 'libopenmpt global variable exists');
                
                // Verify it has the right functions
                if (typeof libopenmpt._openmpt_module_create_from_memory === 'function') {
                    addResult('libopenmpt Functions', 'pass', 'Critical functions available');
                } else {
                    addResult('libopenmpt Functions', 'fail', 'Critical functions missing');
                }
            } else {
                addResult('libopenmpt Global', 'fail', 'libopenmpt global not found');
            }
            
            // Test 3: Check ChiptuneJS
            if (typeof ChiptuneJsConfig !== 'undefined' && typeof ChiptuneJsPlayer !== 'undefined') {
                addResult('ChiptuneJS', 'pass', 'ChiptuneJS classes available');
                
                // Try to create a player
                try {
                    const testPlayer = new ChiptuneJsPlayer(new ChiptuneJsConfig(-1));
                    addResult('ChiptuneJS Player', 'pass', 'Player instance created');
                } catch (error) {
                    addResult('ChiptuneJS Player', 'fail', `Creation failed: ${error.message}`);
                }
            } else {
                addResult('ChiptuneJS', 'fail', 'ChiptuneJS not loaded');
            }
            
            // Test 4: Check TinySynth
            if (typeof WebAudioTinySynth !== 'undefined') {
                addResult('TinySynth', 'pass', 'WebAudioTinySynth available');
                
                try {
                    const synth = new WebAudioTinySynth();
                    addResult('TinySynth Instance', 'pass', 'TinySynth created');
                } catch (error) {
                    addResult('TinySynth Instance', 'fail', `Creation failed: ${error.message}`);
                }
            } else {
                addResult('TinySynth', 'fail', 'WebAudioTinySynth not loaded');
            }
            
            // Test 5: Check helper functions
            const helpers = ['UTF8ToString', 'writeAsciiToMemory'];
            for (const helper of helpers) {
                if (typeof window[helper] === 'function') {
                    addResult(`Helper: ${helper}`, 'pass', 'Function available');
                } else {
                    addResult(`Helper: ${helper}`, 'warn', 'Function not globally available');
                }
            }
            
            // Test 6: Server WASM check
            try {
                const response = await fetch('/api/wasm-check');
                const data = await response.json();
                addResult('Server WASM Check', 'pass', 'Server endpoint working');
                
                for (const [file, info] of Object.entries(data.files)) {
                    if (info && info.exists) {
                        addResult(`Server File: ${file}`, 'pass', `Size: ${info.size} bytes`);
                    } else {
                        addResult(`Server File: ${file}`, 'fail', 'Not found');
                    }
                }
            } catch (error) {
                addResult('Server WASM Check', 'fail', error.message);
            }
        }
        
        function checkOpenMPT() {
            if (window.checkOpenMPTStatus) {
                const status = window.checkOpenMPTStatus();
                log('OpenMPT Status: ' + JSON.stringify(status));
                
                if (status.ready) {
                    addResult('OpenMPT Status', 'pass', 'OpenMPT is fully ready');
                } else {
                    addResult('OpenMPT Status', 'fail', 'OpenMPT not ready: ' + status.message);
                }
                
                for (const [key, value] of Object.entries(status)) {
                    if (key !== 'ready' && key !== 'message') {
                        addResult(`OpenMPT.${key}`, value ? 'pass' : 'fail', String(value));
                    }
                }
            } else {
                addResult('OpenMPT Status', 'fail', 'checkOpenMPTStatus function not found');
            }
        }
        
        async function testChiptunePlayback() {
            try {
                log('Testing Chiptune playback...');
                
                // Get list of music files
                const response = await fetch('/api/music-files');
                const files = await response.json();
                
                const trackerFile = files.find(f => f.type === 'tracker');
                if (!trackerFile) {
                    addResult('Chiptune Test', 'warn', 'No tracker files available');
                    return;
                }
                
                log(`Found tracker file: ${trackerFile.filename}`);
                
                // Download the file
                const fileResponse = await fetch(`/music/${trackerFile.filename}`);
                const arrayBuffer = await fileResponse.arrayBuffer();
                log(`Downloaded ${arrayBuffer.byteLength} bytes`);
                
                // Create player
                const player = new ChiptuneJsPlayer(new ChiptuneJsConfig(-1));
                
                // Try to play
                player.onEnded(() => {
                    log('Playback ended');
                });
                
                player.onError((error) => {
                    log('Playback error: ' + JSON.stringify(error), 'error');
                });
                
                player.play(arrayBuffer);
                
                addResult('Chiptune Playback', 'pass', `Playing ${trackerFile.filename}`);
                
                // Stop after 3 seconds
                setTimeout(() => {
                    player.stop();
                    log('Playback stopped');
                }, 3000);
                
            } catch (error) {
                addResult('Chiptune Playback', 'fail', error.message);
                log('Chiptune test failed: ' + error.message, 'error');
            }
        }
        
        async function testMidiPlayback() {
            try {
                log('Testing MIDI playback...');
                
                // Get list of music files
                const response = await fetch('/api/music-files');
                const files = await response.json();
                
                const midiFile = files.find(f => f.type === 'midi');
                if (!midiFile) {
                    addResult('MIDI Test', 'warn', 'No MIDI files available');
                    
                    // Test with generated notes
                    const synth = new WebAudioTinySynth();
                    synth.send([0x90, 60, 100], 0); // Note on
                    setTimeout(() => {
                        synth.send([0x80, 60, 0], 0); // Note off
                        log('Test note played');
                    }, 1000);
                    
                    addResult('MIDI Test', 'pass', 'TinySynth test note played');
                    return;
                }
                
                log(`Found MIDI file: ${midiFile.filename}`);
                
                // Download and play
                const fileResponse = await fetch(`/music/${midiFile.filename}`);
                const arrayBuffer = await fileResponse.arrayBuffer();
                
                const synth = new WebAudioTinySynth();
                const blob = new Blob([arrayBuffer], { type: 'audio/midi' });
                const url = URL.createObjectURL(blob);
                
                await synth.loadMIDIUrl(url);
                synth.playMIDI();
                
                addResult('MIDI Playback', 'pass', `Playing ${midiFile.filename}`);
                
                setTimeout(() => {
                    synth.stopMIDI();
                    URL.revokeObjectURL(url);
                    log('MIDI playback stopped');
                }, 3000);
                
            } catch (error) {
                addResult('MIDI Playback', 'fail', error.message);
                log('MIDI test failed: ' + error.message, 'error');
            }
        }
        
        async function downloadTestFile() {
            try {
                // Create a small test module pattern
                const testMod = new Uint8Array([
                    0x4D, 0x2E, 0x4B, 0x2E, // M.K. signature (simplified)
                    // ... minimal MOD file structure
                ]);
                
                const blob = new Blob([testMod], { type: 'application/octet-stream' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = 'test.mod';
                a.click();
                
                URL.revokeObjectURL(url);
                
                addResult('Download Test', 'pass', 'Test file downloaded');
            } catch (error) {
                addResult('Download Test', 'fail', error.message);
            }
        }
        
        // Wait for libraries to load
        window.addEventListener('load', () => {
            setTimeout(() => {
                log('Page loaded, waiting for libraries...');
                setTimeout(runTests, 1000);
            }, 500);
        });
        
        // Listen for OpenMPT ready event
        window.addEventListener('openmptReady', (event) => {
            log('OpenMPT Ready Event received!');
            addResult('OpenMPT Event', 'pass', 'openmptReady event fired');
        });
    </script>
</body>
</html>

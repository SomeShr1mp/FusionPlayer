<!DOCTYPE html>
<html>
<head>
    <title>WASM & Audio Library Test</title>
    <style>
        body {
            font-family: monospace;
            background: #000;
            color: #00ff00;
            padding: 20px;
        }
        .test {
            margin: 10px 0;
            padding: 10px;
            border: 1px solid #004400;
        }
        .pass { border-color: #00ff00; background: rgba(0,255,0,0.1); }
        .fail { border-color: #ff0000; background: rgba(255,0,0,0.1); color: #ff4444; }
        .warn { border-color: #ffaa00; background: rgba(255,170,0,0.1); color: #ffaa00; }
        button {
            background: #000;
            border: 2px solid #00ff00;
            color: #00ff00;
            padding: 8px 16px;
            margin: 5px;
            cursor: pointer;
            font-family: monospace;
        }
        button:hover { background: rgba(0,255,0,0.1); }
        #log {
            background: rgba(0,34,0,0.3);
            border: 1px solid #004400;
            padding: 10px;
            margin-top: 20px;
            max-height: 400px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <h1>🔧 WASM & Audio Library Comprehensive Test</h1>
    
    <div id="results"></div>
    
    <h2>Manual Tests</h2>
    <button onclick="checkOpenMPT()">Check OpenMPT Status</button>
    <button onclick="testChiptunePlayback()">Test Chiptune Playback</button>
    <button onclick="testMidiPlayback()">Test MIDI Playback</button>
    <button onclick="downloadTestFile()">Download Test File</button>
    <button onclick="runAllTests()">Run All Tests</button>
    
    <h2>Console Log</h2>
    <div id="log"></div>

    <!-- Load libraries in CRITICAL order -->
    <script src="/js/libopenmpt.js"></script>
    <script src="/js/openmpt-loader.js"></script> <!-- Must be between libopenmpt and chiptune2 -->
    <script src="/js/chiptune2.js"></script>
    <script src="/js/webaudio-tinysynth.js"></script>
    <script src="/js/midi-parser.js"></script>
    
    <script>
        let logBuffer = [];
        let audioContext = null;
        let chiptunePlayer = null;
        let tinySynth = null;
        
        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const entry = `[${timestamp}] ${type.toUpperCase()}: ${message}`;
            console.log(entry);
            logBuffer.push(entry);
            
            const logEl = document.getElementById('log');
            if (logEl) {
                logEl.innerHTML = logBuffer.slice(-50).join('<br>');
                logEl.scrollTop = logEl.scrollHeight;
            }
        }
        
        function addResult(test, status, message) {
            const div = document.createElement('div');
            div.className = `test ${status}`;
            div.innerHTML = `<strong>${test}:</strong> ${status.toUpperCase()} - ${message}`;
            document.getElementById('results').appendChild(div);
            log(`${test}: ${status} - ${message}`, status);
        }
        
        async function runAllTests() {
            document.getElementById('results').innerHTML = '';
            log('Starting comprehensive tests...');
            
            // Test 1: Check if Module exists
            if (typeof Module !== 'undefined') {
                addResult('Module Object', 'pass', 'Emscripten Module exists');
                
                // Check critical functions
                const functions = [
                    '_openmpt_module_create_from_memory',
                    '_openmpt_module_read_float_stereo',
                    '_openmpt_module_destroy',
                    '_malloc',
                    '_free'
                ];
                
                for (const func of functions) {
                    if (typeof Module[func] === 'function') {
                        addResult(`Module.${func}`, 'pass', 'Function available');
                    } else {
                        addResult(`Module.${func}`, 'fail', 'Function not found');
                    }
                }
            } else {
                addResult('Module Object', 'fail', 'Emscripten Module not found');
            }
            
            // Test 2: Check if libopenmpt exists
            if (typeof libopenmpt !== 'undefined') {
                addResult('libopenmpt Global', 'pass', 'libopenmpt global variable exists');
                
                // Verify it has the right functions
                if (typeof libopenmpt._openmpt_module_create_from_memory === 'function') {
                    addResult('libopenmpt Functions', 'pass', 'Critical functions available');
                } else {
                    addResult('libopenmpt Functions', 'fail', 'Critical functions missing');
                }
            } else {
                addResult('libopenmpt Global', 'warn', 'libopenmpt global not found (will be created from Module)');
            }
            
            // Test 3: Check helper functions (CRITICAL for ChiptuneJS)
            if (typeof UTF8ToString !== 'undefined') {
                addResult('UTF8ToString', 'pass', 'Helper function available');
            } else {
                addResult('UTF8ToString', 'fail', 'Helper function missing - ChiptuneJS will fail');
            }
            
            if (typeof writeAsciiToMemory !== 'undefined') {
                addResult('writeAsciiToMemory', 'pass', 'Helper function available');
            } else {
                addResult('writeAsciiToMemory', 'fail', 'Helper function missing - ChiptuneJS may fail');
            }
            
            // Test 4: Check ChiptuneJS
            if (typeof ChiptuneJsConfig !== 'undefined' && typeof ChiptuneJsPlayer !== 'undefined') {
                addResult('ChiptuneJS', 'pass', 'ChiptuneJS classes available');
                
                // Try to create a player with audio context
                try {
                    if (!audioContext) {
                        audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    }
                    const config = new ChiptuneJsConfig(-1, 50, 1, audioContext);
                    const testPlayer = new ChiptuneJsPlayer(config);
                    addResult('ChiptuneJS Player', 'pass', 'Player instance created with audio context');
                } catch (error) {
                    addResult('ChiptuneJS Player', 'fail', `Creation failed: ${error.message}`);
                }
            } else {
                addResult('ChiptuneJS', 'fail', 'ChiptuneJS not loaded');
            }
            
            // Test 5: Check TinySynth
            if (typeof WebAudioTinySynth !== 'undefined') {
                addResult('TinySynth', 'pass', 'WebAudioTinySynth available');
                
                try {
                    const synth = new WebAudioTinySynth({quality: 1, useReverb: 0});
                    addResult('TinySynth Instance', 'pass', 'TinySynth created');
                } catch (error) {
                    addResult('TinySynth Instance', 'fail', `Creation failed: ${error.message}`);
                }
            } else {
                addResult('TinySynth', 'fail', 'WebAudioTinySynth not loaded');
            }
            
            // Test 6: Server WASM check
            try {
                const response = await fetch('/api/wasm-check');
                const data = await response.json();
                addResult('Server WASM Check', 'pass', 'Server endpoint working');
                
                for (const [file, info] of Object.entries(data.files)) {
                    if (info && info.exists) {
                        addResult(`Server File: ${file}`, 'pass', `Size: ${info.size} bytes`);
                    } else {
                        addResult(`Server File: ${file}`, 'warn', 'Not found (not critical if JS works)');
                    }
                }
            } catch (error) {
                addResult('Server WASM Check', 'fail', error.message);
            }
        }
        
        function checkOpenMPT() {
            const status = {
                moduleExists: typeof Module !== 'undefined',
                libopenmptExists: typeof libopenmpt !== 'undefined',
                hasCreateFunction: !!(window.Module && window.Module._openmpt_module_create_from_memory),
                hasReadFunction: !!(window.Module && window.Module._openmpt_module_read_float_stereo),
                hasDestroyFunction: !!(window.Module && window.Module._openmpt_module_destroy),
                hasMalloc: !!(window.Module && window.Module._malloc),
                hasFree: !!(window.Module && window.Module._free),
                hasUTF8ToString: typeof UTF8ToString !== 'undefined',
                hasWriteAscii: typeof writeAsciiToMemory !== 'undefined'
            };
            
            const ready = Object.values(status).every(v => v === true);
            status.ready = ready;
            status.message = ready ? 'OpenMPT is ready' : 'OpenMPT missing components';
            
            log('OpenMPT Status: ' + JSON.stringify(status));
            
            if (ready) {
                addResult('OpenMPT Status', 'pass', 'OpenMPT is fully ready');
            } else {
                addResult('OpenMPT Status', 'fail', 'OpenMPT not ready: ' + status.message);
            }
            
            for (const [key, value] of Object.entries(status)) {
                if (key !== 'ready' && key !== 'message') {
                    addResult(`OpenMPT.${key}`, value ? 'pass' : 'fail', String(value));
                }
            }
        }
        
        async function testChiptunePlayback() {
            try {
                log('Testing Chiptune playback...');
                
                // Initialize audio context if needed
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    if (audioContext.state === 'suspended') {
                        await audioContext.resume();
                    }
                }
                
                // Get list of music files
                const response = await fetch('/api/music-files');
                const files = await response.json();
                
                const trackerFile = files.find(f => f.type === 'tracker');
                if (!trackerFile) {
                    addResult('Chiptune Test', 'warn', 'No tracker files available');
                    return;
                }
                
                log(`Found tracker file: ${trackerFile.filename}`);
                
                // Create player with audio context
                if (!chiptunePlayer) {
                    const config = new ChiptuneJsConfig(-1, 50, 1, audioContext);
                    chiptunePlayer = new ChiptuneJsPlayer(config);
                }
                
                // Load and play
                chiptunePlayer.load(`/music/${trackerFile.filename}`, (buffer) => {
                    if (buffer) {
                        chiptunePlayer.play(buffer);
                        addResult('Chiptune Playback', 'pass', `Playing ${trackerFile.filename}`);
                        
                        // Stop after 3 seconds
                        setTimeout(() => {
                            chiptunePlayer.stop();
                            log('Playback stopped');
                        }, 3000);
                    } else {
                        addResult('Chiptune Playback', 'fail', 'Failed to load file');
                    }
                });
                
            } catch (error) {
                addResult('Chiptune Playback', 'fail', error.message);
                log('Chiptune test failed: ' + error.message, 'error');
            }
        }
        
        async function testMidiPlayback() {
            try {
                log('Testing MIDI playback...');
                
                // Get list of music files
                const response = await fetch('/api/music-files');
                const files = await response.json();
                
                const midiFile = files.find(f => f.type === 'midi');
                if (!midiFile) {
                    addResult('MIDI Test', 'warn', 'No MIDI files available');
                    
                    // Test with generated notes
                    if (!tinySynth) {
                        tinySynth = new WebAudioTinySynth({quality: 1, useReverb: 0});
                    }
                    
                    tinySynth.send([0x90, 60, 100], 0); // Note on
                    setTimeout(() => {
                        tinySynth.send([0x80, 60, 0], 0); // Note off
                        log('Test note played');
                    }, 1000);
                    
                    addResult('MIDI Test', 'pass', 'TinySynth test note played');
                    return;
                }
                
                log(`Found MIDI file: ${midiFile.filename}`);
                
                // Create synth if needed
                if (!tinySynth) {
                    tinySynth = new WebAudioTinySynth({quality: 1, useReverb: 0});
                }
                
                // Load and play
                tinySynth.loadMIDIUrl(`/music/${midiFile.filename}`);
                
                setTimeout(() => {
                    tinySynth.playMIDI();
                    addResult('MIDI Playback', 'pass', `Playing ${midiFile.filename}`);
                    
                    setTimeout(() => {
                        tinySynth.stopMIDI();
                        log('MIDI playback stopped');
                    }, 3000);
                }, 500);
                
            } catch (error) {
                addResult('MIDI Playback', 'fail', error.message);
                log('MIDI test failed: ' + error.message, 'error');
            }
        }
        
        async function downloadTestFile() {
            try {
                // Create a small test module pattern
                const testMod = new Uint8Array([
                    0x4D, 0x2E, 0x4B, 0x2E, // M.K. signature (simplified)
                    // ... minimal MOD file structure
                ]);
                
                const blob = new Blob([testMod], { type: 'application/octet-stream' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = 'test.mod';
                a.click();
                
                URL.revokeObjectURL(url);
                
                addResult('Download Test', 'pass', 'Test file downloaded');
            } catch (error) {
                addResult('Download Test', 'fail', error.message);
            }
        }
        
        // Wait for libraries to load
        window.addEventListener('load', () => {
            setTimeout(() => {
                log('Page loaded, checking libraries...');
                
                // Check initial library status
                const libs = {
                    'Module': typeof Module !== 'undefined',
                    'libopenmpt': typeof libopenmpt !== 'undefined',
                    'ChiptuneJsConfig': typeof ChiptuneJsConfig !== 'undefined',
                    'ChiptuneJsPlayer': typeof ChiptuneJsPlayer !== 'undefined',
                    'WebAudioTinySynth': typeof WebAudioTinySynth !== 'undefined',
                    'UTF8ToString': typeof UTF8ToString !== 'undefined',
                    'writeAsciiToMemory': typeof writeAsciiToMemory !== 'undefined',
                    'MidiParser': typeof MidiParser !== 'undefined'
                };
                
                for (const [name, loaded] of Object.entries(libs)) {
                    if (loaded) {
                        log(`✅ ${name} loaded`);
                    } else {
                        log(`❌ ${name} not loaded`, 'error');
                    }
                }
                
                // Auto-run tests
                setTimeout(runAllTests, 500);
            }, 1000);
        });
        
        // Handle user activation
        document.addEventListener('click', async () => {
            if (audioContext && audioContext.state === 'suspended') {
                await audioContext.resume();
                log('Audio context activated');
            }
        }, { once: true });
    </script>
</body>
</html>

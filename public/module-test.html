<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fusion Music Player - Enhanced Debug Console</title>
    <style>
        body { 
            font-family: 'Courier New', monospace; 
            background: #000; 
            color: #00ff00; 
            padding: 20px;
            margin: 0;
            line-height: 1.4;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            border-bottom: 2px solid #004400;
            padding-bottom: 20px;
        }
        
        .header h1 {
            margin: 0;
            color: #00ff00;
            text-shadow: 0 0 10px #00ff00;
            font-family: 'Courier New', monospace;
        }
        
        .header .version {
            color: #00aa00;
            margin-top: 5px;
        }
        
        .section {
            margin-bottom: 30px;
            border: 1px solid #004400;
            padding: 15px;
            background: rgba(0,68,0,0.1);
        }
        
        .section h2 {
            margin-top: 0;
            color: #00dd00;
            border-bottom: 1px solid #006600;
            padding-bottom: 10px;
        }
        
        .test { 
            margin: 8px 0; 
            padding: 8px; 
            border: 1px solid #004400;
            background: rgba(0,34,0,0.3);
            border-radius: 3px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .test-name {
            font-weight: bold;
            min-width: 200px;
        }
        
        .test-status {
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 11px;
            font-weight: bold;
        }
        
        .pass { 
            border-color: #00ff00; 
            background: rgba(0,255,0,0.1); 
        }
        
        .pass .test-status {
            background: #00aa00;
            color: #000;
        }
        
        .fail { 
            border-color: #ff0000; 
            background: rgba(255,0,0,0.1); 
            color: #ff4444; 
        }
        
        .fail .test-status {
            background: #cc0000;
            color: #fff;
        }
        
        .warn { 
            border-color: #ffaa00; 
            background: rgba(255,170,0,0.1); 
            color: #ffaa00; 
        }
        
        .warn .test-status {
            background: #aa7700;
            color: #fff;
        }
        
        .test-message {
            flex-grow: 1;
            font-size: 12px;
        }
        
        .controls {
            display: flex;
            gap: 6px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        
        button {
            background: #c0c0c0;
            border: 2px outset #c0c0c0;
            color: #000000;
            padding: 4px 12px;
            margin: 2px;
            cursor: pointer;
            font-family: 'MS Sans Serif', sans-serif;
            font-size: 11px;
            min-height: 23px;
        }
        
        button:hover { 
            background: #d4d0c8; 
        }
        
        button:active {
            border: 2px inset #c0c0c0;
        }
        
        button:disabled {
            color: #808080;
            cursor: default;
        }
        
        .library-status {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }
        
        .lib-item {
            padding: 5px;
            border: 1px solid #004400;
            background: rgba(0,34,0,0.3);
            border-radius: 3px;
            font-size: 11px;
        }
        
        .results-container {
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #004400;
            padding: 10px;
            background: rgba(0,17,0,0.5);
        }
        
        .performance-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }
        
        .metric {
            padding: 5px;
            border: 1px solid #004400;
            background: rgba(0,34,0,0.3);
            text-align: center;
            border-radius: 3px;
        }
        
        .metric-value {
            font-size: 14px;
            font-weight: bold;
            color: #00dd00;
        }
        
        .metric-label {
            font-size: 10px;
            color: #00aa00;
        }
        
        .log-container {
            background: rgba(0,0,0,0.8);
            border: 1px solid #004400;
            padding: 10px;
            max-height: 200px;
            overflow-y: auto;
            font-size: 11px;
        }
        
        .log-entry {
            margin: 2px 0;
            padding: 2px 0;
        }
        
        .log-error { color: #ff4444; }
        .log-warn { color: #ffaa00; }
        .log-info { color: #00aa00; }
        .log-debug { color: #666; }
        
        .auto-refresh {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0,34,0,0.8);
            border: 1px solid #004400;
            padding: 10px;
            border-radius: 3px;
        }
        
        select {
            background: #000000;
            color: #00ff00;
            border: 1px solid #00aa00;
            padding: 4px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
        }
        
        select option {
            background: #000000;
            color: #00ff00;
        }
        
        .status-display {
            margin: 10px 0;
            padding: 5px;
            border: 1px solid #004400;
            background: rgba(0,34,0,0.2);
            font-family: 'Courier New', monospace;
            font-size: 11px;
        }
        
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.3; }
        }
        
        .blinking {
            animation: blink 1s infinite;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üîß FUSION MUSIC PLAYER DEBUG CONSOLE</h1>
        <div class="version">Enhanced Debug Suite v2.0 :: Phase 2 Testing :: CRT Terminal Mode</div>
    </div>
    
    <div class="auto-refresh">
        <label>
            <input type="checkbox" id="autoRefresh" checked>
            Auto-refresh (5s)
        </label>
        <div style="font-size: 10px; margin-top: 5px;">
            Last update: <span id="lastUpdate">-</span>
        </div>
    </div>
    
    <div class="section">
        <h2>üöÄ Quick Actions</h2>
        <div class="controls">
            <button onclick="runAllTests()">üîç Run All Tests</button>
            <button onclick="runAudioTests()">üîä Audio Tests</button>
            <button onclick="runLibraryTests()">üìö Library Tests</button>
            <button onclick="runPerformanceTests()">‚ö° Performance Tests</button>
            <button onclick="runDiagnostics()">ü©∫ Full Diagnostics</button>
            <button onclick="clearResults()">üóëÔ∏è Clear Results</button>
            <button onclick="exportResults()">üíæ Export Results</button>
            <button onclick="testAudioPlayback()">üéµ Test Playback</button>
        </div>
    </div>
    
    <div class="section">
        <h2>üìÅ File Selection & Testing</h2>
        <div class="controls">
            <button onclick="listFiles()">üìÇ Load File List</button>
            <button onclick="testFileDownload()">‚¨áÔ∏è Test Download</button>
            <button onclick="playTestTone()">üîä Test Tone</button>
        </div>
        <div id="fileStatus" class="status-display">No files loaded</div>
        <select id="fileSelect" style="width:100%;margin:5px 0;">
            <option value="">Select a file...</option>
        </select>
    </div>
    
    <div class="section">
        <h2>üéµ ChiptuneJS Module Testing</h2>
        <div class="controls">
            <button onclick="testChiptune()">üîß Test ChiptuneJS</button>
            <button onclick="playChiptuneFile()">‚ñ∂Ô∏è Play MOD File</button>
            <button onclick="stopChiptune()">‚èπÔ∏è Stop MOD</button>
        </div>
        <div id="chiptuneStatus" class="status-display">Not tested</div>
    </div>
    
    <div class="section">
        <h2>üéπ TinySynth MIDI Testing</h2>
        <div class="controls">
            <button onclick="testTinySynth()">üîß Test TinySynth</button>
            <button onclick="playTestMidi()">üéº Test MIDI Notes</button>
            <button onclick="playMidiFile()">‚ñ∂Ô∏è Play MIDI File</button>
            <button onclick="stopMidi()">‚èπÔ∏è Stop MIDI</button>
        </div>
        <div id="midiStatus" class="status-display">Not tested</div>
    </div>
    
    <div class="section">
        <h2>üìä System Status</h2>
        <div id="systemOverview"></div>
        <div class="performance-metrics" id="performanceMetrics"></div>
    </div>
    
    <div class="section">
        <h2>üìö Library Status</h2>
        <div class="library-status" id="libraryStatus"></div>
    </div>
    
    <div class="section">
        <h2>üß™ Test Results</h2>
        <div class="results-container" id="results"></div>
    </div>
    
    <div class="section">
        <h2>üìù Console Log</h2>
        <div class="log-container" id="consoleLog"></div>
    </div>

    <!-- Load libraries in same order as main app -->
    <script src="/js/libopenmpt.js" onerror="logError('OpenMPT library failed to load')"></script>
    <script src="/js/chiptune2.js" onerror="logError('Chiptune2 library failed to load')"></script>
    <script src="/js/libfluidsynth-2.3.0.js" onerror="logError('FluidSynth library failed to load')"></script>
    <script src="/js/js-synthesizer.js" onerror="logError('JS-Synthesizer library failed to load')"></script>
    <script src="/js/webaudio-tinysynth.js" onerror="logError('WebAudio TinySynth library failed to load')"></script>
    <script src="/js/midi-parser.js" onerror="logError('MIDI Parser library failed to load')"></script>
    <script src="/js/fallback-audio-engine.js" onerror="logError('Fallback Audio Engine failed to load')"></script>
    <script src="/js/audio-engine.js" onerror="logError('Audio Engine failed to load')"></script>
    <script src="/js/ui-controller.js" onerror="logError('UI Controller failed to load')"></script>
    
    <script>
        // Enhanced debug console with comprehensive testing
        let testResults = [];
        let consoleLog = [];
        let audioEngine = null;
        let uiController = null;
        let startTime = performance.now();
        
        // Audio testing variables from module-test.html
        let testAudioContext = null;
        let chiptunePlayer = null;
        let tinySynth = null;
        let musicFiles = [];
        let currentPlayback = null;
        
        // Capture console output
        const originalConsole = {
            log: console.log,
            warn: console.warn,
            error: console.error,
            info: console.info
        };
        
        function logError(message) {
            addConsoleEntry('error', message);
        }
        
        function addConsoleEntry(type, message) {
            const entry = {
                type: type,
                message: message,
                timestamp: new Date().toISOString(),
                time: performance.now() - startTime
            };
            
            consoleLog.push(entry);
            updateConsoleDisplay();
            
            // Keep only last 100 entries
            if (consoleLog.length > 100) {
                consoleLog = consoleLog.slice(-100);
            }
        }
        
        // Override console methods
        console.log = function(...args) {
            originalConsole.log(...args);
            addConsoleEntry('info', args.join(' '));
        };
        
        console.warn = function(...args) {
            originalConsole.warn(...args);
            addConsoleEntry('warn', args.join(' '));
        };
        
        console.error = function(...args) {
            originalConsole.error(...args);
            addConsoleEntry('error', args.join(' '));
        };
        
        function addResult(test, status, message, details = null) {
            const result = {
                test: test,
                status: status,
                message: message,
                details: details,
                timestamp: new Date().toISOString(),
                time: (performance.now() - startTime).toFixed(2)
            };
            
            testResults.push(result);
            updateResultsDisplay();
            
            const div = document.createElement('div');
            div.className = `test ${status}`;
            div.innerHTML = `
                <div class="test-name">${test}</div>
                <div class="test-status">${status.toUpperCase()}</div>
                <div class="test-message">${message}</div>
            `;
            
            const resultsContainer = document.getElementById('results');
            resultsContainer.appendChild(div);
            
            // Auto-scroll to bottom
            resultsContainer.scrollTop = resultsContainer.scrollHeight;
        }
        
        function checkLibrary(name, checkFunction) {
            try {
                const result = checkFunction();
                if (result) {
                    addResult(`Library: ${name}`, 'pass', 'Available and functional');
                    return true;
                } else {
                    addResult(`Library: ${name}`, 'fail', 'Not available or not functional');
                    return false;
                }
            } catch (error) {
                addResult(`Library: ${name}`, 'fail', `Error: ${error.message}`);
                return false;
            }
        }
        
        async function runAllTests() {
            clearResults();
            addResult('Test Suite', 'info', 'Starting comprehensive test suite...');
            
            const startTime = performance.now();
            
            try {
                await runBasicTests();
                await runAudioTests();
                await runLibraryTests();
                await runAPITests();
                await runPerformanceTests();
                
                const duration = (performance.now() - startTime).toFixed(2);
                addResult('Test Suite', 'pass', `All tests completed in ${duration}ms`);
                
            } catch (error) {
                addResult('Test Suite', 'fail', `Test suite failed: ${error.message}`);
            }
        }
        
        async function runBasicTests() {
            addResult('Basic Tests', 'info', 'Running basic environment tests...');
            
            // Browser detection
            const ua = navigator.userAgent;
            let browser = 'Unknown';
            if (ua.includes('Chrome/')) browser = 'Chrome ' + ua.match(/Chrome\/(\d+)/)[1];
            else if (ua.includes('Firefox/')) browser = 'Firefox ' + ua.match(/Firefox\/(\d+)/)[1];
            else if (ua.includes('Safari/') && !ua.includes('Chrome')) browser = 'Safari';
            else if (ua.includes('Edge/')) browser = 'Edge';
            
            addResult('Browser Detection', 'pass', browser);
            
            // JavaScript features
            addResult('ES6 Support', typeof Promise !== 'undefined' ? 'pass' : 'fail', 
                     typeof Promise !== 'undefined' ? 'Promise support available' : 'No Promise support');
            
            addResult('Fetch API', typeof fetch !== 'undefined' ? 'pass' : 'fail',
                     typeof fetch !== 'undefined' ? 'Fetch API available' : 'Fetch API not available');
            
            // Web Audio API
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            if (AudioContext) {
                addResult('Web Audio API', 'pass', 'Supported');
                
                // Test AudioWorklet support
                if (AudioContext.prototype.audioWorklet) {
                    addResult('AudioWorklet Support', 'pass', 'Supported');
                } else {
                    addResult('AudioWorklet Support', 'fail', 'Not supported in this browser');
                }
                
                // Test Web Audio features
                try {
                    const tempContext = new AudioContext();
                    addResult('AudioContext Creation', 'pass', `Sample rate: ${tempContext.sampleRate}Hz`);
                    
                    if (tempContext.audioWorklet) {
                        addResult('AudioWorklet Available', 'pass', 'AudioWorklet interface available');
                    } else {
                        addResult('AudioWorklet Available', 'fail', 'AudioWorklet not available');
                    }
                    
                    tempContext.close();
                } catch (error) {
                    addResult('AudioContext Creation', 'fail', error.message);
                }
            } else {
                addResult('Web Audio API', 'fail', 'Not supported');
            }
            
            // WebAssembly
            addResult('WebAssembly Support', typeof WebAssembly !== 'undefined' ? 'pass' : 'fail',
                     typeof WebAssembly !== 'undefined' ? 'WebAssembly available' : 'WebAssembly not available');
        }
        
        async function runAudioTests() {
            addResult('Audio Tests', 'info', 'Running audio system tests...');
            
            try {
                // Test audio context creation and setup
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                const testContext = new AudioContext();
                
                addResult('Audio Context State', 'pass', `Initial state: ${testContext.state}`);
                
                // Test basic audio nodes
                const gainNode = testContext.createGain();
                const oscillator = testContext.createOscillator();
                
                addResult('Audio Nodes', 'pass', 'GainNode and OscillatorNode created successfully');
                
                // Test audio context resume (user activation required)
                if (testContext.state === 'suspended') {
                    addResult('Audio Context', 'warn', 'Context suspended - user interaction required');
                } else {
                    addResult('Audio Context', 'pass', 'Context running');
                }
                
                // Test AudioWorklet if available
                if (testContext.audioWorklet) {
                    try {
                        await testContext.audioWorklet.addModule('/js/audio-worklet-processor.js');
                        addResult('AudioWorklet Module', 'pass', 'Audio worklet processor loaded successfully');
                        
                        const workletNode = new AudioWorkletNode(testContext, 'fusion-audio-processor');
                        addResult('AudioWorklet Node', 'pass', 'AudioWorkletNode created successfully');
                        
                        workletNode.disconnect();
                    } catch (error) {
                        addResult('AudioWorklet Module', 'fail', `Failed to load: ${error.message}`);
                    }
                }
                
                testContext.close();
                
            } catch (error) {
                addResult('Audio Tests', 'fail', `Audio test failed: ${error.message}`);
            }
        }
        
        async function runLibraryTests() {
            addResult('Library Tests', 'info', 'Testing audio library availability...');
            
            // Wait a bit for libraries to load
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            // Test core application classes
            addResult('AudioEngine class', typeof AudioEngine !== 'undefined' ? 'pass' : 'fail', 
                     typeof AudioEngine !== 'undefined' ? 'Loaded' : 'Missing audio-engine.js');
            
            addResult('UIController class', typeof UIController !== 'undefined' ? 'pass' : 'fail', 
                     typeof UIController !== 'undefined' ? 'Loaded' : 'Missing ui-controller.js');
            
            addResult('FallbackAudioEngine class', typeof FallbackAudioEngine !== 'undefined' ? 'pass' : 'fail', 
                     typeof FallbackAudioEngine !== 'undefined' ? 'Loaded' : 'Missing fallback-audio-engine.js');
            
            // Test audio libraries
            checkLibrary('OpenMPT Module', () => typeof Module !== 'undefined');
            checkLibrary('ChiptuneJS Config', () => typeof ChiptuneJsConfig !== 'undefined');
            checkLibrary('ChiptuneJS Player', () => typeof ChiptuneJsPlayer !== 'undefined');
            checkLibrary('JSSynth', () => typeof JSSynth !== 'undefined');
            checkLibrary('WebAudioTinySynth', () => typeof WebAudioTinySynth !== 'undefined');
            checkLibrary('LibFluidSynth', () => typeof LibFluidSynth !== 'undefined');
            checkLibrary('MidiParser', () => typeof MidiParser !== 'undefined');
        }
        
        async function runAPITests() {
            addResult('API Tests', 'info', 'Testing server API endpoints...');
            
            try {
                // Test music files endpoint
                const filesResponse = await fetch('/api/music-files');
                if (filesResponse.ok) {
                    const files = await filesResponse.json();
                    addResult('Music Files API', 'pass', `Found ${files.length} files`);
                    
                    if (files.length > 0) {
                        const firstFile = files[0];
                        addResult('Sample File', 'pass', `${firstFile.filename} (${firstFile.displaySize || 'unknown size'})`);
                        
                        // Test file access
                        const fileResponse = await fetch(`/music/${firstFile.filename}`, { method: 'HEAD' });
                        if (fileResponse.ok) {
                            addResult('File Access', 'pass', `Can access ${firstFile.filename}`);
                        } else {
                            addResult('File Access', 'fail', `Cannot access ${firstFile.filename}: HTTP ${fileResponse.status}`);
                        }
                    } else {
                        addResult('File Access Test', 'warn', 'No files available for testing');
                    }
                } else {
                    addResult('Music Files API', 'fail', `HTTP ${filesResponse.status}: ${filesResponse.statusText}`);
                }
                
                // Test SoundFont access
                const sfResponse = await fetch('/soundfonts/default.sf2', { method: 'HEAD' });
                if (sfResponse.ok) {
                    addResult('SoundFont Access', 'pass', `Default SoundFont available (${sfResponse.headers.get('content-length')} bytes)`);
                } else {
                    addResult('SoundFont Access', 'warn', 'Default SoundFont not found - MIDI playback may use built-in sounds');
                }
                
            } catch (error) {
                addResult('API Tests', 'fail', `API test failed: ${error.message}`);
            }
        }
        
        async function runPerformanceTests() {
            addResult('Performance Tests', 'info', 'Running performance benchmarks...');
            
            try {
                // Memory usage
                if (performance.memory) {
                    const memory = performance.memory;
                    addResult('Memory Usage', 'pass', 
                        `Used: ${(memory.usedJSHeapSize/1024/1024).toFixed(2)}MB, ` +
                        `Total: ${(memory.totalJSHeapSize/1024/1024).toFixed(2)}MB`);
                }
                
                // Timing API
                if (performance.now) {
                    const start = performance.now();
                    await new Promise(resolve => setTimeout(resolve, 10));
                    const end = performance.now();
                    addResult('High Resolution Timing', 'pass', `Precision: ${(end - start).toFixed(3)}ms`);
                }
                
                // Test AudioContext latency if available
                try {
                    const testContext = new (window.AudioContext || window.webkitAudioContext)();
                    if (testContext.baseLatency !== undefined) {
                        addResult('Audio Latency', 'pass', 
                            `Base: ${(testContext.baseLatency * 1000).toFixed(2)}ms, ` +
                            `Output: ${testContext.outputLatency ? (testContext.outputLatency * 1000).toFixed(2) + 'ms' : 'N/A'}`);
                    }
                    testContext.close();
                } catch (error) {
                    addResult('Audio Latency', 'warn', 'Could not measure audio latency');
                }
                
            } catch (error) {
                addResult('Performance Tests', 'fail', `Performance test failed: ${error.message}`);
            }
        }
        
        async function runDiagnostics() {
            clearResults();
            addResult('Diagnostics', 'info', 'Running comprehensive system diagnostics...');
            
            try {
                // Initialize audio engine for testing
                if (typeof AudioEngine !== 'undefined') {
                    audioEngine = new AudioEngine();
                    await audioEngine.initialize();
                    
                    const diagnostics = await audioEngine.runDiagnostics();
                    addResult('Audio Engine Diagnostics', 'pass', 'Diagnostics completed - check console for details');
                }
                
                // Initialize UI controller for testing
                if (typeof UIController !== 'undefined') {
                    uiController = new UIController();
                    await uiController.initialize();
                    
                    const uiDiagnostics = uiController.runDiagnostics();
                    addResult('UI Controller Diagnostics', 'pass', 'UI diagnostics completed - check console for details');
                }
                
                updateSystemOverview();
                
            } catch (error) {
                addResult('Diagnostics', 'fail', `Diagnostics failed: ${error.message}`);
            }
        }
        
        async function testAudioPlayback() {
            if (!audioEngine) {
                addResult('Playback Test', 'fail', 'Audio engine not initialized - run diagnostics first');
                return;
            }
            
            try {
                addResult('Playback Test', 'info', 'Testing audio playback...');
                
                // Get available files
                const response = await fetch('/api/music-files');
                const files = await response.json();
                
                if (files.length === 0) {
                    addResult('Playback Test', 'warn', 'No music files available for testing');
                    return;
                }
                
                const testFile = files[0];
                addResult('Playback Test', 'info', `Testing with: ${testFile.filename}`);
                
                await audioEngine.playTrack(testFile);
                
                // Stop playback after 2 seconds
                setTimeout(() => {
                    if (audioEngine) {
                        audioEngine.stop();
                        addResult('Playback Test', 'pass', 'Playback test completed successfully');
                    }
                }, 2000);
                
            } catch (error) {
                addResult('Playback Test', 'fail', `Playback test failed: ${error.message}`);
            }
        }
        
        function clearResults() {
            testResults = [];
            document.getElementById('results').innerHTML = '';
        }
        
        function exportResults() {
            const data = {
                timestamp: new Date().toISOString(),
                userAgent: navigator.userAgent,
                testResults: testResults,
                consoleLog: consoleLog,
                performanceMetrics: getPerformanceMetrics()
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `fusion-debug-${new Date().toISOString().slice(0,19).replace(/:/g,'-')}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            addResult('Export', 'pass', 'Debug results exported successfully');
        }
        
        // ===== MODULE-TEST.HTML FUNCTIONALITY =====
        
        async function playTestTone() {
            if (!testAudioContext) {
                await initTestAudioContext();
            }
            
            if (!testAudioContext) {
                addResult('Test Tone', 'fail', 'AudioContext not available');
                return;
            }
            
            try {
                addResult('Test Tone', 'info', 'Playing 440Hz test tone...');
                
                const oscillator = testAudioContext.createOscillator();
                const gainNode = testAudioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(testAudioContext.destination);
                
                oscillator.frequency.setValueAtTime(440, testAudioContext.currentTime);
                oscillator.type = 'sine';
                
                gainNode.gain.setValueAtTime(0.1, testAudioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, testAudioContext.currentTime + 1);
                
                oscillator.start();
                oscillator.stop(testAudioContext.currentTime + 1);
                
                addResult('Test Tone', 'pass', 'Test tone played successfully');
            } catch (error) {
                addResult('Test Tone', 'fail', `Test tone failed: ${error.message}`);
            }
        }
        
        async function initTestAudioContext() {
            try {
                if (testAudioContext) {
                    testAudioContext.close();
                }
                
                testAudioContext = new (window.AudioContext || window.webkitAudioContext)();
                addResult('Test AudioContext', 'pass', `AudioContext created (${testAudioContext.state})`);
                
                if (testAudioContext.state === 'suspended') {
                    await testAudioContext.resume();
                    addResult('Test AudioContext', 'pass', `AudioContext resumed (${testAudioContext.state})`);
                }
                
                return true;
            } catch (error) {
                addResult('Test AudioContext', 'fail', `AudioContext creation failed: ${error.message}`);
                return false;
            }
        }
        
        async function listFiles() {
            try {
                addResult('File List', 'info', 'Fetching music files from server...');
                
                const response = await fetch('/api/music-files');
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                musicFiles = await response.json();
                addResult('File List', 'pass', `Found ${musicFiles.length} music files`);
                
                // Populate file selector
                const select = document.getElementById('fileSelect');
                select.innerHTML = '<option value="">Select a file...</option>';
                
                musicFiles.forEach((file, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = `${file.filename} (${file.type} - ${file.displaySize || 'unknown size'})`;
                    select.appendChild(option);
                });
                
                document.getElementById('fileStatus').textContent = `‚úì Found ${musicFiles.length} files`;
                document.getElementById('fileStatus').style.color = '#00ff00';
                
            } catch (error) {
                addResult('File List', 'fail', `File listing failed: ${error.message}`);
                document.getElementById('fileStatus').textContent = `‚úó Failed: ${error.message}`;
                document.getElementById('fileStatus').style.color = '#ff4444';
            }
        }
        
        async function testFileDownload() {
            const select = document.getElementById('fileSelect');
            const selectedIndex = select.value;
            
            if (!selectedIndex || !musicFiles[selectedIndex]) {
                addResult('File Download', 'fail', 'Please select a file first');
                return;
            }
            
            const file = musicFiles[selectedIndex];
            
            try {
                addResult('File Download', 'info', `Testing download of ${file.filename}...`);
                
                const response = await fetch(`/music/${file.filename}`);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const arrayBuffer = await response.arrayBuffer();
                addResult('File Download', 'pass', `Downloaded ${file.filename} (${arrayBuffer.byteLength} bytes)`);
                
                return arrayBuffer;
            } catch (error) {
                addResult('File Download', 'fail', `Download failed: ${error.message}`);
                throw error;
            }
        }
        
        function testChiptune() {
            try {
                addResult('ChiptuneJS Test', 'info', 'Testing ChiptuneJS availability...');
                
                const libs = {
                    'Module': typeof Module !== 'undefined',
                    'ChiptuneJsConfig': typeof ChiptuneJsConfig !== 'undefined',
                    'ChiptuneJsPlayer': typeof ChiptuneJsPlayer !== 'undefined'
                };
                
                Object.entries(libs).forEach(([name, available]) => {
                    addResult(`ChiptuneJS ${name}`, available ? 'pass' : 'fail', 
                        available ? 'Available' : 'Not available');
                });
                
                if (!libs.ChiptuneJsConfig || !libs.ChiptuneJsPlayer) {
                    throw new Error('ChiptuneJS not loaded properly');
                }
                
                if (!testAudioContext) {
                    throw new Error('Test AudioContext not initialized');
                }
                
                addResult('ChiptuneJS Player', 'info', 'Creating ChiptuneJS player...');
                chiptunePlayer = new ChiptuneJsPlayer(new ChiptuneJsConfig(-1, testAudioContext));
                
                addResult('ChiptuneJS Player', 'pass', 'ChiptuneJS player created successfully');
                document.getElementById('chiptuneStatus').textContent = '‚úì Ready';
                document.getElementById('chiptuneStatus').style.color = '#00ff00';
                
            } catch (error) {
                addResult('ChiptuneJS Test', 'fail', `ChiptuneJS test failed: ${error.message}`);
                document.getElementById('chiptuneStatus').textContent = `‚úó Failed: ${error.message}`;
                document.getElementById('chiptuneStatus').style.color = '#ff4444';
            }
        }
        
        async function playChiptuneFile() {
            const select = document.getElementById('fileSelect');
            const selectedIndex = select.value;
            
            if (!selectedIndex || !musicFiles[selectedIndex]) {
                addResult('ChiptuneJS Play', 'fail', 'Please select a file first');
                return;
            }
            
            const file = musicFiles[selectedIndex];
            
            if (file.type !== 'tracker') {
                addResult('ChiptuneJS Play', 'fail', 'Please select a tracker file (.mod, .xm, .it, .s3m)');
                return;
            }
            
            if (!chiptunePlayer) {
                addResult('ChiptuneJS Play', 'info', 'ChiptuneJS not initialized. Running test...');
                await initTestAudioContext();
                testChiptune();
                if (!chiptunePlayer) {
                    addResult('ChiptuneJS Play', 'fail', 'ChiptuneJS initialization failed');
                    return;
                }
            }
            
            try {
                addResult('ChiptuneJS Play', 'info', `Loading ${file.filename} with ChiptuneJS...`);
                
                const arrayBuffer = await testFileDownload();
                
                addResult('ChiptuneJS Play', 'info', 'File downloaded, loading with ChiptuneJS...');
                
                // Stop any current playback
                if (currentPlayback) {
                    try {
                        chiptunePlayer.stop();
                    } catch (e) {
                        console.warn('Error stopping previous playback:', e);
                    }
                }
                
                // Try the play method directly (some ChiptuneJS versions work this way)
                if (typeof chiptunePlayer.play === 'function') {
                    try {
                        chiptunePlayer.play(arrayBuffer);
                        addResult('ChiptuneJS Play', 'pass', `Playing ${file.filename} with ChiptuneJS`);
                        currentPlayback = { type: 'chiptune', player: chiptunePlayer };
                        
                        // Set up event handlers if available
                        if (chiptunePlayer.onEnded) {
                            chiptunePlayer.onEnded = () => {
                                addResult('ChiptuneJS Playback', 'info', 'Playback ended');
                                currentPlayback = null;
                            };
                        }
                        
                        return;
                    } catch (playError) {
                        addResult('ChiptuneJS Play', 'warn', `Direct play failed: ${playError.message}`);
                    }
                }
                
                // Try callback-based loading
                if (typeof chiptunePlayer.load === 'function') {
                    addResult('ChiptuneJS Play', 'info', 'Using callback-based loading...');
                    
                    chiptunePlayer.load(arrayBuffer, (error) => {
                        if (error) {
                            addResult('ChiptuneJS Play', 'fail', `Load callback error: ${error}`);
                        } else {
                            addResult('ChiptuneJS Play', 'pass', 'Load successful, starting playback...');
                            try {
                                chiptunePlayer.play();
                                addResult('ChiptuneJS Play', 'pass', `Playing ${file.filename}`);
                                currentPlayback = { type: 'chiptune', player: chiptunePlayer };
                            } catch (playError) {
                                addResult('ChiptuneJS Play', 'fail', `Play error: ${playError.message}`);
                            }
                        }
                    });
                } else {
                    addResult('ChiptuneJS Play', 'fail', 'No suitable play method found');
                    addResult('ChiptuneJS Play', 'info', `Available methods: ${Object.getOwnPropertyNames(chiptunePlayer)}`);
                }
                
            } catch (error) {
                addResult('ChiptuneJS Play', 'fail', `Playback failed: ${error.message}`);
            }
        }
        
        function stopChiptune() {
            if (chiptunePlayer && currentPlayback?.type === 'chiptune') {
                try {
                    chiptunePlayer.stop();
                    addResult('ChiptuneJS Stop', 'pass', 'ChiptuneJS playback stopped');
                    currentPlayback = null;
                } catch (error) {
                    addResult('ChiptuneJS Stop', 'fail', `Stop failed: ${error.message}`);
                }
            } else {
                addResult('ChiptuneJS Stop', 'warn', 'No ChiptuneJS playback to stop');
            }
        }
        
        function testTinySynth() {
            try {
                addResult('TinySynth Test', 'info', 'Testing TinySynth availability...');
                
                if (typeof WebAudioTinySynth === 'undefined') {
                    throw new Error('WebAudioTinySynth not loaded');
                }
                
                if (!testAudioContext) {
                    throw new Error('Test AudioContext not initialized');
                }
                
                addResult('TinySynth Test', 'info', 'Creating TinySynth instance...');
                tinySynth = new WebAudioTinySynth({
                    quality: 1,
                    useReverb: 1,
                    voices: 32
                });
                
                addResult('TinySynth Test', 'pass', 'TinySynth created successfully');
                addResult('TinySynth Test', 'info', `Available methods: ${Object.getOwnPropertyNames(tinySynth)}`);
                
                document.getElementById('midiStatus').textContent = '‚úì Ready';
                document.getElementById('midiStatus').style.color = '#00ff00';
                
            } catch (error) {
                addResult('TinySynth Test', 'fail', `TinySynth test failed: ${error.message}`);
                document.getElementById('midiStatus').textContent = `‚úó Failed: ${error.message}`;
                document.getElementById('midiStatus').style.color = '#ff4444';
            }
        }
        
        async function playTestMidi() {
            if (!tinySynth) {
                addResult('Test MIDI', 'info', 'TinySynth not initialized. Running test...');
                await initTestAudioContext();
                testTinySynth();
                if (!tinySynth) {
                    addResult('Test MIDI', 'fail', 'TinySynth initialization failed');
                    return;
                }
            }
            
            try {
                addResult('Test MIDI', 'info', 'Playing test MIDI sequence...');
                
                // Test C major chord progression
                const chords = [
                    [60, 64, 67], // C major
                    [62, 65, 69], // D minor  
                    [64, 67, 71], // E minor
                    [65, 69, 72]  // F major
                ];
                
                let noteTime = 0;
                chords.forEach((chord, chordIndex) => {
                    chord.forEach(note => {
                        setTimeout(() => {
                            addResult('Test MIDI', 'info', `Playing note ${note}`);
                            tinySynth.send([0x90, note, 100], 0); // Note on
                            
                            setTimeout(() => {
                                tinySynth.send([0x80, note, 0], 0); // Note off
                            }, 800);
                        }, noteTime);
                        noteTime += 50;
                    });
                    noteTime += 750;
                });
                
                addResult('Test MIDI', 'pass', 'Test MIDI sequence started');
                
            } catch (error) {
                addResult('Test MIDI', 'fail', `Test MIDI failed: ${error.message}`);
            }
        }
        
        async function playMidiFile() {
            const select = document.getElementById('fileSelect');
            const selectedIndex = select.value;
            
            if (!selectedIndex || !musicFiles[selectedIndex]) {
                addResult('MIDI File Play', 'fail', 'Please select a file first');
                return;
            }
            
            const file = musicFiles[selectedIndex];
            
            if (file.type !== 'midi') {
                addResult('MIDI File Play', 'fail', 'Please select a MIDI file (.mid, .midi)');
                return;
            }
            
            if (!tinySynth) {
                addResult('MIDI File Play', 'info', 'TinySynth not initialized. Running test...');
                await initTestAudioContext();
                testTinySynth();
                if (!tinySynth) {
                    addResult('MIDI File Play', 'fail', 'TinySynth initialization failed');
                    return;
                }
            }
            
            try {
                addResult('MIDI File Play', 'info', `Loading MIDI file ${file.filename}...`);
                
                const arrayBuffer = await testFileDownload();
                
                // Stop any current playback
                if (currentPlayback) {
                    stopMidi();
                }
                
                addResult('MIDI File Play', 'info', 'MIDI file downloaded, attempting to play...');
                
                // Try different TinySynth loading methods
                if (typeof tinySynth.loadMIDIUrl === 'function') {
                    addResult('MIDI File Play', 'info', 'Using loadMIDIUrl method...');
                    
                    const blob = new Blob([new Uint8Array(arrayBuffer)], { type: 'audio/midi' });
                    const url = URL.createObjectURL(blob);
                    
                    await tinySynth.loadMIDIUrl(url);
                    tinySynth.playMIDI();
                    
                    addResult('MIDI File Play', 'pass', `Playing ${file.filename} with TinySynth`);
                    currentPlayback = { type: 'midi', player: tinySynth, url: url };
                    
                    // Clean up URL later
                    setTimeout(() => URL.revokeObjectURL(url), 5000);
                    
                } else if (typeof tinySynth.loadMIDI === 'function') {
                    addResult('MIDI File Play', 'info', 'Using loadMIDI method...');
                    
                    const uint8Array = new Uint8Array(arrayBuffer);
                    tinySynth.loadMIDI(uint8Array);
                    
                    if (typeof tinySynth.play === 'function') {
                        tinySynth.play();
                    } else if (typeof tinySynth.playMIDI === 'function') {
                        tinySynth.playMIDI();
                    }
                    
                    addResult('MIDI File Play', 'pass', `Playing ${file.filename} with TinySynth`);
                    currentPlayback = { type: 'midi', player: tinySynth };
                    
                } else {
                    addResult('MIDI File Play', 'fail', 'No suitable MIDI loading method found');
                    addResult('MIDI File Play', 'info', `Available methods: ${Object.getOwnPropertyNames(tinySynth)}`);
                }
                
            } catch (error) {
                addResult('MIDI File Play', 'fail', `MIDI playback failed: ${error.message}`);
                console.error('Detailed MIDI error:', error);
            }
        }
        
        function stopMidi() {
            if (tinySynth && currentPlayback?.type === 'midi') {
                try {
                    if (typeof tinySynth.stop === 'function') {
                        tinySynth.stop();
                    } else if (typeof tinySynth.stopMIDI === 'function') {
                        tinySynth.stopMIDI();
                    }
                    
                    // Send all notes off
                    for (let channel = 0; channel < 16; channel++) {
                        tinySynth.send([0xB0 | channel, 123, 0], 0); // All notes off
                    }
                    
                    addResult('MIDI Stop', 'pass', 'MIDI playback stopped');
                    
                    if (currentPlayback.url) {
                        URL.revokeObjectURL(currentPlayback.url);
                    }
                    
                    currentPlayback = null;
                } catch (error) {
                    addResult('MIDI Stop', 'fail', `Stop failed: ${error.message}`);
                }
            } else {
                addResult('MIDI Stop', 'warn', 'No MIDI playback to stop');
            }
        }
        
        // ===== END MODULE-TEST.HTML FUNCTIONALITY =====
        
        function updateLibraryStatus() {
            const status = document.getElementById('libraryStatus');
            const libs = {
                'OpenMPT Module': typeof Module !== 'undefined',
                'ChiptuneJS Config': typeof ChiptuneJsConfig !== 'undefined',
                'ChiptuneJS Player': typeof ChiptuneJsPlayer !== 'undefined',
                'JSSynth': typeof JSSynth !== 'undefined',
                'WebAudioTinySynth': typeof WebAudioTinySynth !== 'undefined',
                'LibFluidSynth': typeof LibFluidSynth !== 'undefined',
                'AudioEngine': typeof AudioEngine !== 'undefined',
                'UIController': typeof UIController !== 'undefined',
                'FallbackAudioEngine': typeof FallbackAudioEngine !== 'undefined',
                'MidiParser': typeof MidiParser !== 'undefined'
            };
            
            status.innerHTML = Object.entries(libs)
                .map(([name, loaded]) => 
                    `<div class="lib-item" style="color: ${loaded ? '#00ff00' : '#ff4444'}">
                        ${name}: ${loaded ? '‚úì' : '‚úó'}
                    </div>`
                )
                .join('');
        }
        
        function updateSystemOverview() {
            const overview = document.getElementById('systemOverview');
            
            let browser = 'Unknown';
            const ua = navigator.userAgent;
            if (ua.includes('Chrome/')) browser = 'Chrome ' + ua.match(/Chrome\/(\d+)/)[1];
            else if (ua.includes('Firefox/')) browser = 'Firefox ' + ua.match(/Firefox\/(\d+)/)[1];
            else if (ua.includes('Safari/') && !ua.includes('Chrome')) browser = 'Safari';
            else if (ua.includes('Edge/')) browser = 'Edge';
            
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            let audioWorkletSupported = false;
            
            try {
                // Safe AudioWorklet detection
                if (AudioContext && AudioContext.prototype && AudioContext.prototype.audioWorklet) {
                    audioWorkletSupported = true;
                }
            } catch (error) {
                console.warn('Error checking AudioWorklet support:', error);
                audioWorkletSupported = false;
            }
            
            const info = {
                'Browser': browser,
                'Audio API': AudioContext ? '‚úì' : '‚úó',
                'AudioWorklet': audioWorkletSupported ? '‚úì' : '‚úó',
                'WebAssembly': typeof WebAssembly !== 'undefined' ? '‚úì' : '‚úó',
                'Libraries Loaded': Object.keys(window).filter(key => 
                    ['Module', 'ChiptuneJsConfig', 'JSSynth', 'WebAudioTinySynth', 'LibFluidSynth', 'AudioEngine', 'UIController', 'FallbackAudioEngine'].includes(key)
                ).length,
                'Test Results': testResults.length,
                'Console Entries': consoleLog.length
            };
            
            overview.innerHTML = Object.entries(info)
                .map(([key, value]) => `<strong>${key}:</strong> ${value}`)
                .join(' | ');
        }
        
        function updatePerformanceMetrics() {
            const metrics = document.getElementById('performanceMetrics');
            const data = getPerformanceMetrics();
            
            metrics.innerHTML = Object.entries(data)
                .map(([key, value]) => 
                    `<div class="metric">
                        <div class="metric-value">${value}</div>
                        <div class="metric-label">${key}</div>
                    </div>`
                )
                .join('');
        }
        
        function getPerformanceMetrics() {
            return {
                'Uptime': `${((performance.now() - startTime) / 1000).toFixed(1)}s`,
                'Memory': performance.memory ? `${(performance.memory.usedJSHeapSize/1024/1024).toFixed(1)}MB` : 'N/A',
                'Tests': testResults.length,
                'Errors': consoleLog.filter(entry => entry.type === 'error').length
            };
        }
        
        function updateConsoleDisplay() {
            const logContainer = document.getElementById('consoleLog');
            logContainer.innerHTML = consoleLog.slice(-20).map(entry => 
                `<div class="log-entry log-${entry.type}">
                    [${new Date(entry.timestamp).toLocaleTimeString()}] ${entry.message}
                </div>`
            ).join('');
            
            logContainer.scrollTop = logContainer.scrollHeight;
        }
        
        function updateResultsDisplay() {
            // Update last update timestamp
            document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString();
        }
        
        // Auto-refresh functionality
        function setupAutoRefresh() {
            const checkbox = document.getElementById('autoRefresh');
            
            setInterval(() => {
                if (checkbox.checked) {
                    updateLibraryStatus();
                    updateSystemOverview();
                    updatePerformanceMetrics();
                    updateResultsDisplay();
                }
            }, 5000);
        }
        
        // Initialize on page load
        window.addEventListener('load', () => {
            setupAutoRefresh();
            
            setTimeout(async () => {
                updateLibraryStatus();
                updateSystemOverview();
                updatePerformanceMetrics();
                updateResultsDisplay();
                
                // Initialize test audio context
                addConsoleEntry('info', 'Initializing test audio context...');
                await initTestAudioContext();
                
                // Auto-load file list
                addConsoleEntry('info', 'Auto-loading music file list...');
                await listFiles();
                
                // Run initial basic tests
                runBasicTests();
                
                addConsoleEntry('info', 'Debug console ready for comprehensive testing');
            }, 1000);
        });
        
        // Add some helpful keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey || e.metaKey) {
                switch (e.key) {
                    case 'r':
                        e.preventDefault();
                        runAllTests();
                        break;
                    case 's':
                        e.preventDefault();
                        exportResults();
                        break;
                    case 'c':
                        e.preventDefault();
                        clearResults();
                        break;
                }
            }
        });
        
        console.log('üîß Enhanced Debug Console v2.0 loaded (CRT Terminal Mode)');
        console.log('üí° Keyboard shortcuts: Ctrl+R (run tests), Ctrl+S (export), Ctrl+C (clear)');
    </script>
</body>
</html>
